import { Express, Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { Server } from 'http';
import { masterDb } from './multi-tenant-db.js';
import { insertNotificationSchema, insertUserSchema, ProductSchema, schema } from '@shared/schema.js';
import { eq, sql } from 'drizzle-orm';
import z from 'zod';
import {  requireSuperAdmin } from './authMiddleware';
import bcrypt from 'bcrypt';
import express from 'express';
import multer from 'multer';
import { SupabaseStorageManager } from './supabase-storage';
import type { AuthUser } from '@shared/auth';
import { 
  storage,
  getMasterStorage,
  getTenantStorage,
  getTenantStorageForUser,
  validateTenantAccess
} from './storage/index.js';
// Agregar despu√©s de: import type { AuthUser } from '@shared/auth';
import { 
  storage,                    // Compatibilidad temporal
  getMasterStorage,           // Para operaciones master directas
  getTenantStorage,          // Para operaciones tenant directas
  getTenantStorageForUser,   // Helper para usuarios autenticados
  validateTenantAccess       // Validaci√≥n de acceso
import { getTenantDb } from './multi-tenant-db.js';
import { createTenantStorage } from './tenant-storage.js';




const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';



const router = express.Router();


// Configurar multer para manejo de archivos en memoria
const upload = multer({ 
  storage: multer.memoryStorage(),
  limits: { 
    fileSize: 5 * 1024 * 1024, // 5MB por archivo
    files: 5 // M√°ximo 5 archivos
  },
  // ‚úÖ CORRECCI√ìN del error en routes.ts:
fileFilter: (req, file, cb) => {
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    // ‚úÖ CORREGIDO: Solo Error, sin false
    cb(new Error(`Tipo de archivo no permitido: ${file.mimetype}`));
  }
}
});

// Middleware para tenant storage optimizado
const requireTenantStorage = async (req: any, res: any, next: any) => {
  try {
    const user = req.user;
    
    if (!user.storeId) {
      return res.status(400).json({ error: 'Store ID required for this operation' });
    }
    
    await validateTenantAccess(user.storeId);
    const tenantStorage = await getTenantStorage(user.storeId);
    
    req.tenantStorage = tenantStorage;
    next();
  } catch (error) {
    console.error('Tenant storage validation failed:', error);
    res.status(500).json({ error: 'Failed to access store data' });
  }
};

async function processProductImages(
  files: Express.Multer.File[],
  imageUrls: string[],
  storeId: number,
  productId?: number
): Promise<string[]> {
  const processedImages: string[] = [];

  try {
    // OPCI√ìN 1: Con Supabase Storage (cuando est√© listo)
    if (process.env.SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY) {
      const storageManager = new SupabaseStorageManager(storeId);
      
      // Procesar archivos subidos
      for (const file of files) {
        const fileObject = new File([file.buffer], file.originalname, { type: file.mimetype });
        const imageUrl = await storageManager.uploadFile(fileObject, productId);
        processedImages.push(imageUrl);
      }

      // Procesar URLs de im√°genes
      for (const url of imageUrls) {
        const imageUrl = await storageManager.uploadFromUrl(url, productId);
        processedImages.push(imageUrl);
      }
    } 
    // OPCI√ìN 2: Placeholder para desarrollo (tu versi√≥n actual)
    else {
      console.log('üìÅ USING PLACEHOLDER STORAGE - Configure Supabase for production');
      
      // Procesar archivos subidos
      for (const file of files) {
        const imageUrl = `https://storage.example.com/store-${storeId}/product-${productId}/${Date.now()}-${file.originalname}`;
        processedImages.push(imageUrl);
      }

      // Procesar URLs de im√°genes
      for (const url of imageUrls) {
        try {
          const response = await fetch(url, { method: 'HEAD' });
          if (response.ok) {
            processedImages.push(url);
          }
        } catch (error) {
          console.warn(`Error validating image URL: ${url}`, error);
        }
      }
    }

    return processedImages;
  } catch (error) {
    console.error('Error processing images:', error);
    throw error;
  }
}



const createProductHandler = async (req: any, res: any) => {
  try {
    const user = req.user as AuthUser;
    const files = req.files as Express.Multer.File[] || [];
    
    console.log('üì¶ Creating product for store:', user.storeId);
    
    // Parsear datos del producto
    const productData = {
      ...req.body,
      isActive: req.body.isActive === 'true',
      stock: parseInt(req.body.stock) || 0,
      warrantyMonths: parseInt(req.body.warrantyMonths) || 0,
    };

    // Parsear URLs de im√°genes si existen
    let imageUrls: string[] = [];
    if (req.body.imageUrls) {
      try {
        imageUrls = JSON.parse(req.body.imageUrls);
      } catch {
        imageUrls = [];
      }
    }

    // Validar datos
    const validatedData = ProductSchema.parse({
      ...productData,
      imageUrls
    });

    // Validar l√≠mite total de im√°genes
    const totalImages = files.length + imageUrls.length;
    if (totalImages > 5) {
      return res.status(400).json({
        error: "M√°ximo 5 im√°genes permitidas en total"
      });
    }

    // ‚úÖ USAR SOLO TENANT STORAGE - ESQUEMA INDEPENDIENTE
    const tenantStorage = await getTenantStorageForUser(user);
    
    // ‚úÖ NO AGREGAR storeId - cada esquema ES la tienda
    const productToCreate = {
      ...validatedData,
      images: [] // Temporal, se actualizar√° despu√©s
      // ‚ùå NO INCLUIR: storeId: user.storeId (innecesario en esquema independiente)
    };

    console.log('üíæ Creating product in tenant schema:', productToCreate);
    console.log('üöÄ NEW PRODUCT PAYLOAD ->', JSON.stringify(productToCreate, null, 2));

    const product = await tenantStorage.createProduct(productToCreate);

    // Procesar y subir im√°genes
    let finalImageUrls: string[] = [];
    if (totalImages > 0) {
      finalImageUrls = await processProductImages(
        files,
        imageUrls,
        user.storeId!,
        product.id
      );

      // ‚úÖ Actualizar usando TENANT STORAGE
      await tenantStorage.updateProduct(product.id, {
        images: finalImageUrls
      });
    }

    console.log('‚úÖ Product created in independent schema for store:', user.storeId);

    res.status(201).json({
      ...product,
      images: finalImageUrls
    });

  } catch (error) {
    console.error('Error creating product:', error);
    
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: "Datos inv√°lidos",
        details: error.errors
      });
    }

    if (error instanceof multer.MulterError) {
      return res.status(400).json({
        error: error.message
      });
    }

    res.status(500).json({
      error: "Error interno del servidor"
    });
  }
};
const deleteProductHandler = async (req: any, res: any) => {
  try {
    const user = req.user as AuthUser;
    const productId = parseInt(req.params.id);

    console.log('üóëÔ∏è Deleting product', productId, 'from store schema:', user.storeId);

    // ‚úÖ USAR SOLO TENANT STORAGE - ESQUEMA INDEPENDIENTE
    const tenantStorage = await getTenantStorageForUser(user);
    
    // Verificar que el producto existe EN EL SCHEMA DE LA TIENDA
    const product = await tenantStorage.getProductById(productId);

    if (!product) {
      console.log('‚ùå Product not found in store schema:', user.storeId);
      return res.status(404).json({ error: "Producto no encontrado" });
    }

    // ‚úÖ Eliminar del schema independiente (retorna void)
    await tenantStorage.deleteProduct(productId);

    console.log('‚úÖ Product deleted from independent schema');
    res.json({ success: true });

  } catch (error) {
    console.error('Error deleting product:', error);
    
    // Manejar errores espec√≠ficos
    if (error instanceof Error) {
      if (error.message.includes('constraint') || error.message.includes('foreign key')) {
        return res.status(400).json({ 
          error: "No se puede eliminar: el producto est√° siendo usado en √≥rdenes existentes" 
        });
      }
    }
    
    res.status(500).json({
      error: "Error interno del servidor"
    });
  }
};

const getProductsHandler = async (req: any, res: any) => {
  try {
    const user = req.user as AuthUser;
    
    console.log('üìã Getting products for store schema:', user.storeId);
    
    // ‚úÖ USAR SOLO TENANT STORAGE - VE SOLO SUS PRODUCTOS
    const tenantStorage = await getTenantStorageForUser(user);
    
    const products = await tenantStorage.getAllProducts();
    
    console.log(`‚úÖ Retrieved ${products.length} products from independent schema`);
    res.json(products);
  } catch (error) {
    console.error('Error fetching products:', error);
    res.status(500).json({
      error: "Error interno del servidor"
    });
  }
};

const getProductByIdHandler = async (req: any, res: any) => {
  try {
    const user = req.user as AuthUser;
    const productId = parseInt(req.params.id);

    console.log('üîç Getting product', productId, 'for store schema:', user.storeId);

    // ‚úÖ USAR SOLO TENANT STORAGE - B√öSQUEDA EN ESQUEMA INDEPENDIENTE
    const tenantStorage = await getTenantStorageForUser(user);
    
    const product = await tenantStorage.getProductById(productId);

    if (!product) {
      console.log('‚ùå Product not found in store schema:', user.storeId);
      return res.status(404).json({ error: "Producto no encontrado" });
    }

    console.log('‚úÖ Product found in independent schema');
    res.json(product);
  } catch (error) {
    console.error('Error fetching product:', error);
    res.status(500).json({
      error: "Error interno del servidor"
    });
  }
};


const getCategoriesHandler = async (req: any, res: any) => {
  try {
    const user = req.user as AuthUser;
    
    console.log('üìÇ Getting categories for store schema:', user.storeId);
    
    // ‚úÖ USAR TENANT STORAGE
    const tenantStorage = await getTenantStorageForUser(user);
    
    const categories = await tenantStorage.getAllCategories();
    
    console.log(`‚úÖ Retrieved ${categories.length} categories from independent schema`);
    res.json(categories);
  } catch (error) {
    console.error('Error fetching categories:', error);
    res.status(500).json({
      error: "Error interno del servidor"
    });
  }
};

const createCategoryHandler = async (req: any, res: any) => {
  try {
    const user = req.user as AuthUser;
    
    console.log('üìÅ Creating category for store schema:', user.storeId);
    
    // ‚úÖ USAR TENANT STORAGE
    const tenantStorage = await getTenantStorageForUser(user);
    
    // ‚úÖ NO AGREGAR storeId - cada esquema ES la tienda
    const categoryData = { ...req.body };
    
    const category = await tenantStorage.createCategory(categoryData);

    console.log('‚úÖ Category created in independent schema');
    res.status(201).json(category);
  } catch (error) {
    console.error('Error creating category:', error);
    res.status(500).json({
      error: "Error interno del servidor"
    });
  }
};

const updateCategoryHandler = async (req: any, res: any) => {
  try {
    const user = req.user as AuthUser;
    const categoryId = parseInt(req.params.id);
    
    console.log('‚úèÔ∏è Updating category', categoryId, 'in store schema:', user.storeId);
    
    // ‚úÖ USAR TENANT STORAGE
    const tenantStorage = await getTenantStorageForUser(user);
    
    // ‚úÖ NO AGREGAR storeId
    const updateData = { ...req.body };
    
    const category = await tenantStorage.updateCategory(categoryId, updateData);

    if (!category) {
      return res.status(404).json({ error: "Categor√≠a no encontrada" });
    }

    console.log('‚úÖ Category updated in independent schema');
    res.json(category);
  } catch (error) {
    console.error('Error updating category:', error);
    res.status(500).json({
      error: "Error interno del servidor"
    });
  }
};

const deleteCategoryHandler = async (req: any, res: any) => {
  try {
    const user = req.user as AuthUser;
    const categoryId = parseInt(req.params.id);
    
    console.log('üóëÔ∏è Deleting category', categoryId, 'from store schema:', user.storeId);
    
    // ‚úÖ USAR TENANT STORAGE
    const tenantStorage = await getTenantStorageForUser(user);
    
    // Verificar existencia
    const category = await tenantStorage.getCategoryById(categoryId);
    if (!category) {
      return res.status(404).json({ error: "Categor√≠a no encontrada" });
    }
    
    // ‚úÖ Eliminar (retorna void)
    await tenantStorage.deleteCategory(categoryId);
    
    console.log('‚úÖ Category deleted from independent schema');
    res.json({ success: true });
  } catch (error) {
    console.error('Error deleting category:', error);
    
    if (error instanceof Error && error.message.includes('constraint')) {
      return res.status(400).json({ 
        error: "No se puede eliminar: la categor√≠a tiene productos asociados" 
      });
    }
    
    res.status(500).json({
      error: "Error interno del servidor"
    });
  }
};

// ‚úÖ QUICK FIX - Reemplace el updateProductHandler incompleto con este c√≥digo

// üî• DIAGN√ìSTICO COMPLETO BACKEND - Reemplazar updateProductHandler en routes.ts

// üöÄ FIX INMEDIATO - updateProductHandler SIMPLIFICADO
// REEMPLAZAR en routes.ts - Este DEBE funcionar

const updateProductHandler = async (req: any, res: any) => {
  console.log('üöÄ SIMPLE FIX - Starting update for product:', req.params.id);
  console.log('üöÄ Store ID:', req.user?.storeId);
  console.log('üöÄ Body keys received:', Object.keys(req.body || {}));
  
  try {
    const user = req.user as AuthUser;
    const productId = parseInt(req.params.id);

    // ‚úÖ VALIDACIONES B√ÅSICAS
    if (!user || !user.storeId) {
      console.error('‚ùå No user or storeId');
      return res.status(401).json({ error: 'Unauthorized' });
    }

    if (!req.body || Object.keys(req.body).length === 0) {
      console.error('‚ùå Empty request body');
      return res.status(400).json({ error: 'Empty request body' });
    }

    // ‚úÖ EXTRAER DATOS B√ÅSICOS (solo los que sabemos que funcionan)
    const productData: any = {};

    // Campos b√°sicos que aparecen en el Network tab
    if (req.body.name && req.body.name.trim()) {
      productData.name = req.body.name.trim();
      console.log('‚úÖ Added name:', productData.name);
    }

    if (req.body.description && req.body.description.trim()) {
      productData.description = req.body.description.trim();
      console.log('‚úÖ Added description');
    }

    if (req.body.price) {
      productData.price = parseFloat(req.body.price);
      console.log('‚úÖ Added price:', productData.price);
    }

    if (req.body.category && req.body.category.trim()) {
      productData.category = req.body.category.trim();
      console.log('‚úÖ Added category:', productData.category);
    }

    if (req.body.type && req.body.type.trim()) {
      productData.type = req.body.type.trim();
      console.log('‚úÖ Added type:', productData.type);
    }

    if (req.body.brand && req.body.brand.trim()) {
      productData.brand = req.body.brand.trim();
      console.log('‚úÖ Added brand:', productData.brand);
    }

    if (req.body.sku && req.body.sku.trim()) {
      productData.sku = req.body.sku.trim();
      console.log('‚úÖ Added sku:', productData.sku);
    }

    if (req.body.stock !== undefined) {
      productData.stock = parseInt(req.body.stock) || 0;
      console.log('‚úÖ Added stock:', productData.stock);
    }

    if (req.body.warrantyMonths !== undefined) {
      productData.warrantyMonths = parseInt(req.body.warrantyMonths) || 0;
      console.log('‚úÖ Added warrantyMonths:', productData.warrantyMonths);
    }

    if (req.body.isActive !== undefined) {
      productData.isActive = req.body.isActive === 'true' || req.body.isActive === true;
      console.log('‚úÖ Added isActive:', productData.isActive);
    }

    console.log('üìä Final productData:', productData);
    console.log('üìä Fields count:', Object.keys(productData).length);

    // ‚úÖ VERIFICACI√ìN CR√çTICA
    if (Object.keys(productData).length === 0) {
      console.error('‚ùå No valid fields extracted');
      console.error('‚ùå Original body:', req.body);
      return res.status(400).json({
        error: "No valid data to update",
        debug: {
          bodyKeys: Object.keys(req.body),
          extractedKeys: Object.keys(productData)
        }
      });
    }

    // ‚úÖ USAR TENANT STORAGE
    console.log('üè™ Getting tenant storage...');
    const tenantStorage = await getTenantStorageForUser(user);

    // ‚úÖ VERIFICAR PRODUCTO EXISTE
    console.log('üîç Checking if product exists...');
    const existingProduct = await tenantStorage.getProductById(productId);
    if (!existingProduct) {
      console.error('‚ùå Product not found:', productId);
      return res.status(404).json({ error: "Producto no encontrado" });
    }

    console.log('‚úÖ Product found:', existingProduct.name);

    // ‚úÖ ACTUALIZAR PRODUCTO
    console.log('üíæ Updating product with data:', Object.keys(productData));
    const updatedProduct = await tenantStorage.updateProduct(productId, productData);

    console.log('üéâ UPDATE SUCCESSFUL!');

    res.json({
      success: true,
      product: updatedProduct
    });

  } catch (error) {
    console.error('üí• ERROR in updateProductHandler:', error);
    console.error('üí• Error message:', error.message);
    console.error('üí• Error stack:', error.stack);

    if (error.message && error.message.includes('No values to set')) {
      console.error('üéØ DRIZZLE ERROR: This means productData was empty when passed to updateProduct');
    }

    res.status(500).json({
      error: error.message || "Error interno del servidor",
      debug: error.message
    });
  }
};

// ‚úÖ SOLUCI√ìN DEFINITIVA - Compatible con tenant-storage.ts


const deleteOrderHandler = async (req: any, res: any) => {
  try {
    const user = req.user as AuthUser;
    const orderId = parseInt(req.params.id);
    
    const tenantStorage = await getTenantStorageForUser(user);
    
    // Verificar existencia
    const order = await tenantStorage.getOrderById(orderId);
    if (!order) {
      return res.status(404).json({ error: "Orden no encontrada" });
    }
    
    // ‚úÖ Eliminar - retorna void
    await tenantStorage.deleteOrder(orderId);
    
    res.json({ success: true });
    
  } catch (error) {
    console.error('Error deleting order:', error);
    res.status(500).json({ error: "Error interno del servidor" });
  }
};


const deleteCustomerHandler = async (req: any, res: any) => {
  try {
    const user = req.user as AuthUser;
    const customerId = parseInt(req.params.id);
    
    const tenantStorage = await getTenantStorageForUser(user);
    
    // Verificar existencia
    const customer = await tenantStorage.getCustomerById(customerId);
    if (!customer) {
      return res.status(404).json({ error: "Cliente no encontrado" });
    }
    
    // ‚úÖ Eliminar - retorna void
    await tenantStorage.deleteCustomer(customerId);
    
    res.json({ success: true });
    
  } catch (error) {
    console.error('Error deleting customer:', error);
    
    if (error instanceof Error && error.message.includes('constraint')) {
      return res.status(400).json({ 
        error: "No se puede eliminar: el cliente tiene √≥rdenes asociadas" 
      });
    }
    
    res.status(500).json({ error: "Error interno del servidor" });
  }
};

const validateImageUrlHandler = async (req: any, res: any) => {
  try {
    const { url } = req.body;

    if (!url) {
      return res.status(400).json({ error: "URL requerida" });
    }

    // Validar formato de URL
    try {
      new URL(url);
    } catch {
      return res.status(400).json({ error: "URL inv√°lida" });
    }

    // Verificar que sea una imagen accesible
    const response = await fetch(url, { method: 'HEAD' });
    
    if (!response.ok) {
      return res.status(400).json({ error: "No se pudo acceder a la imagen" });
    }

    const contentType = response.headers.get('content-type');
    if (!contentType || !contentType.startsWith('image/')) {
      return res.status(400).json({ error: "La URL no apunta a una imagen" });
    }

    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
    if (!allowedTypes.includes(contentType)) {
      return res.status(400).json({ error: "Formato de imagen no permitido" });
    }

    // Verificar tama√±o si est√° disponible
    const contentLength = response.headers.get('content-length');
    if (contentLength && parseInt(contentLength) > 5 * 1024 * 1024) {
      return res.status(400).json({ error: "La imagen es muy grande (m√°ximo 5MB)" });
    }

    res.json({ 
      valid: true, 
      contentType,
      size: contentLength ? parseInt(contentLength) : null
    });

  } catch (error) {
    console.error('Error validating image URL:', error);
    res.status(500).json({
      error: "Error al validar la URL"
    });
  }
};





/**
 * ENDPOINT PARA VALIDAR URL DE IMAGEN
 */


function generateGoogleMapsLink(latitude: string | number, longitude: string | number, address?: string): string {
  const lat = parseFloat(latitude.toString());
  const lng = parseFloat(longitude.toString());
  
  if (isNaN(lat) || isNaN(lng)) {
    return address || 'Ubicaci√≥n no disponible';
  }
  
  const baseUrl = 'https://www.google.com/maps/search/';
  
  if (address && address.trim() !== '') {
    return `${baseUrl}${encodeURIComponent(address)}/@${lat},${lng},15z`;
  } else {
    return `${baseUrl}@${lat},${lng},15z`;
  }
}

function formatCurrency(amount: number): string {
  return new Intl.NumberFormat('es-MX', {
    style: 'currency',
    currency: 'MXN'
  }).format(amount);
}

function authenticateToken(req: any, res: any, next: any) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (token == null) return res.sendStatus(401);

  jwt.verify(token, JWT_SECRET, (err: any, user: any) => {
    if (err) return res.sendStatus(403);
    req.user = user;
    next();
  });
}

// server/routes.ts - Actualizaciones para usar nuevos m√©todos



export function setupUserManagementRoutes(app: any, storage: any) {

  // ========================================
  // ENDPOINTS PARA USUARIOS GLOBALES (Super Admins)
  // ========================================

  // Crear super admin o system admin
  app.post('/api/super-admin/global-users', authenticateToken, requireSuperAdmin, async (req: Request, res: Response) => {
    try {
      const { name, username, email, password, role } = req.body;

      // Validar que el rol sea apropiado para usuarios globales
      if (!['super_admin', 'system_admin'].includes(role)) {
        return res.status(400).json({ error: 'Invalid role for global user' });
      }

      // Hash de la contrase√±a
      const hashedPassword = await bcrypt.hash(password, 10);

      // Crear usuario global
      const newUser = await storage.createGlobalUser({
        name,
        username,
        email,
        password: hashedPassword,
        role,
        status: 'active',
        isActive: true
      });

      res.status(201).json({
        id: newUser.id,
        username: newUser.username,
        name: newUser.name,
        email: newUser.email,
        role: newUser.role,
        message: 'Global user created successfully'
      });

    } catch (error) {
      console.error('Error creating global user:', error);
      if (error instanceof Error && error.message.includes('already exists')) {
        return res.status(400).json({ error: error.message });
      }
      res.status(500).json({ error: 'Failed to create global user' });
    }
  });

  // Listar usuarios globales
  app.get('/api/super-admin/global-users', authenticateToken, requireSuperAdmin, async (req: Request, res: Response) => {
    try {
      const users = await storage.listGlobalUsers();
      res.json(users);
    } catch (error) {
      console.error('Error fetching global users:', error);
      res.status(500).json({ error: 'Failed to fetch global users' });
    }
  });

  // ========================================
  // ENDPOINTS PARA USUARIOS DE TIENDA (Store Users)
  // ========================================

  // Crear usuario de tienda (store_owner, store_admin) - ACTUALIZADO
  app.post('/api/super-admin/users', authenticateToken, requireSuperAdmin, async (req: Request, res: Response) => {
    try {
      const { name, email, role, storeId, username, password, sendInvitation, invitationMessage } = req.body;

      // Validar que la tienda existe
      const [store] = await masterDb
        .select()
        .from(schema.virtualStores)
        .where(eq(schema.virtualStores.id, storeId))
        .limit(1);

      if (!store) {
        return res.status(400).json({ error: 'Store not found' });
      }

      // Generar username autom√°ticamente si no se proporciona
      const finalUsername = username || `${name.toLowerCase().replace(/\s+/g, '')}_${Date.now()}`;

      // Generar contrase√±a temporal si no se proporciona
      const tempPassword = password || Math.random().toString(36).slice(-8) + Math.random().toString(36).slice(-4).toUpperCase();

      // Hash de la contrase√±a
      const hashedPassword = await bcrypt.hash(tempPassword, 10);

      // ‚úÖ USAR NUEVO M√âTODO: createStoreUser
      const newUser = await storage.createStoreUser({
        name,
        username: finalUsername,
        email,
        password: hashedPassword,
        role,
        storeId,
        isActive: true
      });

      // TODO: Implementar env√≠o de email si sendInvitation es true
      const invitationSent = false;

      res.status(201).json({
        id: newUser.id,
        username: newUser.username,
        name: newUser.name,
        email: newUser.email,
        role: newUser.role,
        storeId: newUser.storeId,
        isActive: newUser.isActive,
        tempPassword: tempPassword,
        storeName: store.name,
        invitationSent: invitationSent
      });

    } catch (error) {
      console.error('Error creating store user:', error);
      if (error instanceof Error && error.message.includes('already exists')) {
        return res.status(400).json({ error: error.message });
      }
      res.status(500).json({ error: 'Failed to create store user' });
    }
  });

  // Listar usuarios de tienda - ACTUALIZADO
  app.get('/api/super-admin/users', authenticateToken, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const users = await storage.listStoreUsers(); // ‚Üê Este ahora retorna StoreUserListItem[]
    res.json(users);
  } catch (error) {
      console.error('Error fetching store users:', error);
      res.status(500).json({ error: 'Failed to fetch store users' });
    }
  });

  // Obtener usuarios de una tienda espec√≠fica
  app.get('/api/super-admin/stores/:storeId/store-users', authenticateToken, requireSuperAdmin, async (req: Request, res: Response) => {
    try {
      const storeId = parseInt(req.params.storeId);
      
      // ‚úÖ USAR NUEVO M√âTODO: getStoreUsersByStoreId
      const users = await storage.getStoreUsersByStoreId(storeId);
      res.json(users);
    } catch (error) {
      console.error('Error fetching store users:', error);
      res.status(500).json({ error: 'Failed to fetch store users' });
    }
  });

  // ========================================
  // ENDPOINTS PARA USUARIOS OPERACIONALES (Tenant Users)
  // ========================================

  // Obtener usuarios operacionales de una tienda
  app.get('/api/stores/:storeId/users', authenticateToken, async (req: Request, res: Response) => {
    try {
      const storeId = parseInt(req.params.storeId);
      const user = req.user as AuthUser;

      // Verificar permisos
      if (user.role !== 'super_admin' && user.storeId !== storeId) {
        return res.status(403).json({ error: 'Access denied to this store' });
      }

      // ‚úÖ USAR NUEVO M√âTODO: listTenantUsers
      const users = await storage.listTenantUsers(storeId);
      res.json(users);
    } catch (error) {
      console.error('Error fetching tenant users:', error);
      res.status(500).json({ error: 'Failed to fetch tenant users' });
    }
  });

  // Crear usuario operacional en schema de tienda - ACTUALIZADO
  app.post('/api/stores/:storeId/users', authenticateToken, async (req: Request, res: Response) => {
    try {
      const storeId = parseInt(req.params.storeId);
      const user = req.user as AuthUser;
      const { username, name, email, role, department, password } = req.body;

      // Verificar permisos
      if (user.role !== 'super_admin' && user.storeId !== storeId) {
        return res.status(403).json({ error: 'Access denied to this store' });
      }

      // Hash de la contrase√±a
      const hashedPassword = await bcrypt.hash(password, 10);

      // ‚úÖ USAR NUEVO M√âTODO: createTenantUser
      const newUser = await storage.createTenantUser(storeId, {
        username,
        name,
        email,
        password: hashedPassword,
        role,
        department,
        status: 'active',
        isActive: true
      });

      res.status(201).json(newUser);
    } catch (error) {
      console.error('Error creating tenant user:', error);
      if (error instanceof Error && error.message.includes('already exists')) {
        return res.status(400).json({ error: error.message });
      }
      res.status(500).json({ error: 'Failed to create tenant user' });
    }
  });

  // ========================================
  // ENDPOINTS DE UTILIDAD
  // ========================================

  // Buscar usuario en todos los niveles
  app.get('/api/super-admin/users/search/:username', authenticateToken, requireSuperAdmin, async (req: Request, res: Response) => {
    try {
      const { username } = req.params;
      
      // ‚úÖ USAR NUEVO M√âTODO: findUserAnyLevel
      const result = await storage.findUserAnyLevel(username);
      
      if (!result.user) {
        return res.status(404).json({ error: 'User not found in any level' });
      }

      res.json({
        user: result.user,
        level: result.level,
        storeId: result.storeId
      });
    } catch (error) {
      console.error('Error searching user:', error);
      res.status(500).json({ error: 'Failed to search user' });
    }
  });

  // Estad√≠sticas de usuarios
  app.get('/api/super-admin/user-metrics', authenticateToken, requireSuperAdmin, async (req: Request, res: Response) => {
    try {
      // ‚úÖ USAR NUEVO M√âTODO: getUserStats
      const stats = await storage.getUserStats();
      
      res.json({
        totalUsers: stats.globalUsers + stats.storeUsers,
        activeUsers: stats.activeStoreUsers,
        storeOwners: stats.usersByRole.store_owner || 0,
        superAdmins: stats.globalUsers,
        suspendedUsers: stats.storeUsers - stats.activeStoreUsers,
        newUsersThisMonth: 0, // TODO: implementar l√≥gica de fecha
        globalUsers: stats.globalUsers,
        storeUsers: stats.storeUsers,
        usersByRole: stats.usersByRole
      });
    } catch (error) {
      console.error('Error fetching user metrics:', error);
      res.status(500).json({ error: 'Failed to fetch user metrics' });
    }
  });

  // ========================================
  // ENDPOINT DE MIGRACI√ìN/COMPATIBILIDAD
  // ========================================

  // Migrar usuario de tabla users a system_users (si fuera necesario)
  app.post('/api/super-admin/migrate-user/:userId', authenticateToken, requireSuperAdmin, async (req: Request, res: Response) => {
    try {
      const userId = parseInt(req.params.userId);
      const { targetStoreId } = req.body;

      // Obtener usuario de tabla users
      const globalUser = await masterDb
        .select()
        .from(schema.users)
        .where(eq(schema.users.id, userId))
        .limit(1);

      if (globalUser.length === 0) {
        return res.status(404).json({ error: 'Global user not found' });
      }

      const user = globalUser[0];

      // Verificar que no sea super_admin
      if (user.role === 'super_admin') {
        return res.status(400).json({ error: 'Cannot migrate super admin users' });
      }

      // Crear en system_users
      const migratedUser = await storage.createStoreUser({
        name: user.name,
        username: `migrated_${user.username}`,
        email: user.email,
        password: user.password, // Ya est√° hasheada
        role: user.role,
        storeId: targetStoreId,
        isActive: user.isActive
      });

      res.json({
        message: 'User migrated successfully',
        originalUser: user,
        migratedUser: migratedUser
      });

    } catch (error) {
      console.error('Error migrating user:', error);
      res.status(500).json({ error: 'Failed to migrate user' });
    }
  });
}

export async function registerRoutes(app: Express): Promise<any> {
  // Import storage dynamically to avoid dependency issues
 
  // Multi-tenant WhatsApp message processing function
  async function processWhatsAppMessage(value: any) {
    console.log('üéØ PROCESSWHATSAPPMESSAGE - Iniciando procesamiento');
    console.log('üöÄ WEBHOOK RECEIVED - Function called successfully');
    
    // CRITICAL FIX: Use simple processor instead of complex routing
    console.log('üîÑ DELEGATING TO SIMPLE PROCESSOR - Bypassing complex routing');
    const { processWhatsAppMessageSimple } = await import('./whatsapp-simple.js');
    await processWhatsAppMessageSimple(value);
    return;
  }

  
  // Function to process customer messages and responses
  async function processCustomerMessage(customer: any, conversation: any, message: any, from: string, isNewCustomer: boolean = false, storeId?: number, phoneNumberId?: string) {
    try {
      const text = message.text?.body || '';
      console.log('üîÄ PROCESSADA CUSTOMERMESSAGE - Mensaje:', text, 'storeId:', storeId);

      // PRIORITY 1: Check if message is a structured order from web catalog
      const isOrder = await isOrderMessage(text);
      
      if (isOrder) {
        console.log('üõçÔ∏è ORDER DETECTED - Processing catalog order via simple processor');
        // Let simple processor handle order processing
        return;
      }

      // For non-order messages, process as normal conversation
      console.log('üí¨ REGULAR MESSAGE - Processing as conversation');
      // Additional conversation processing logic can be added here
      
    } catch (error) {
      console.error('Error in processCustomerMessage:', error);
    }
  }

  
  // Additional utility functions
  async function isOrderMessage(text: string): Promise<boolean> {
    return text.startsWith('üõçÔ∏è *NUEVO PEDIDO*');
  }

  // WhatsApp webhook endpoint
  app.post('/webhook', async (req: Request, res: Response) => {
    try {
      const value = req.body;
      console.log('üéØ WEBHOOK RECEIVED - Processing WhatsApp message');
      
      await processWhatsAppMessage(value);
      
      res.sendStatus(200);
    } catch (error) {
      console.error('Error in webhook processing:', error);
      res.sendStatus(500);
    }
  });

  // WhatsApp webhook verification
  app.get('/webhook', (req: Request, res: Response) => {
    const VERIFY_TOKEN = process.env.VERIFY_TOKEN || 'verifytoken12345';
    const mode = req.query['hub.mode'];
    const token = req.query['hub.verify_token'];
    const challenge = req.query['hub.challenge'];

    if (mode && token) {
      if (mode === 'subscribe' && token === VERIFY_TOKEN) {
        console.log('WEBHOOK_VERIFIED');
        res.status(200).send(challenge);
      } else {
        res.sendStatus(403);
      }
    }
  });


  // Users routes
  app.get("/api/users", async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      res.json(users);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch users" });
    }
  });

// En routes.ts, l√≠nea 147 aproximadamente:
app.post("/api/users", authenticateToken, async (req, res) => {
  try {
    const user = (req as any).user;
    const userData = { ...req.body, storeId: user.storeId };
    
    const newUser = await storage.createStoreUser(userData);
    res.status(201).json(newUser);
  } catch (error) {
    console.error("Error creating user:", error);
    res.status(500).json({ error: "Failed to create user" });
  }
});

  app.patch("/api/users/:id/status", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { status } = z.object({ status: z.string() }).parse(req.body);
      
      const user = await storage.updateUserStatus(id, status);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      res.json(user);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: "Invalid status data", details: error.errors });
      }
      res.status(500).json({ error: "Failed to update user status" });
    }
  });

// ‚úÖ USA SCHEMA DE TIENDA
app.get("/api/registration-flows", authenticateToken, async (req, res) => {
  try {
    const user = (req as any).user;
    
    // Usar tenant storage en lugar de storage global
    const { getTenantDb } = await import('./multi-tenant-db.js');
    const { createTenantStorage } = await import('./tenant-storage.js');
    
   const tenantStorage = await getTenantStorageForUser(user);
    
    const flows = await tenantStorage.getAllRegistrationFlows(); // ‚Üê Schema de tienda
    res.json(flows);
  } catch (error) {
    console.error("Error getting registration flows:", error);
    res.status(500).json({ error: "Failed to fetch registration flows" });
  }
});

// ‚úÖ USA SCHEMA DE TIENDA
app.post("/api/registration-flows", authenticateToken, async (req, res) => {
  try {
    const user = (req as any).user;
    const flowData = req.body;
    
    // Usar tenant storage
    const { getTenantDb } = await import('./multi-tenant-db.js');
    const { createTenantStorage } = await import('./tenant-storage.js');
    
    const tenantStorage = await getTenantStorageForUser(user);
    
    const flow = await tenantStorage.createRegistrationFlow(flowData); // ‚Üê Schema de tienda
    res.status(201).json(flow);
  } catch (error) {
    console.error("Error creating registration flow:", error);
    res.status(500).json({ error: "Failed to create registration flow" });
  }
});
  // Dentro de registerRoutes() en routes.ts
app.get("/api/super-admin/subscriptions", (req, res) => {
  res.json([]); // o tu l√≥gica real si ya tienes datos
});

app.get("/api/super-admin/subscription-metrics", (req, res) => {
  res.json({
    total: 0,
    active: 0,
    expired: 0
  });
});


    // M√©tricas globales del sistema
  app.get('/api/super-admin/metrics', async (req, res) => {
    try {
      // Obtener m√©tricas de todas las tiendas
      const stores = await masterDb.select().from(schema.virtualStores);
      const users = await masterDb.select().from(schema.systemUsers);
      
      // Calcular m√©tricas agregadas
      const totalStores = stores.length;
      const activeStores = stores.filter(store => store.isActive).length;
      const totalUsers = users.length;
      
      // Calcular m√©tricas reales desde la base de datos
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      // Contar √≥rdenes totales y del d√≠a
      const [totalOrdersResult] = await masterDb
        .select({ count: sql<number>`count(*)` })
        .from(schema.orders);
      
      const [todayOrdersResult] = await masterDb
        .select({ count: sql<number>`count(*)` })
        .from(schema.orders)
        .where(sql`DATE(${schema.orders.createdAt}) = DATE(${new Date().toISOString()})`);
      
      // Contar mensajes WhatsApp totales
      const [totalMessagesResult] = await masterDb
        .select({ count: sql<number>`count(*)` })
        .from(schema.messages);
      
      // Calcular ingresos totales
      const [revenueResult] = await masterDb
        .select({ total: sql<number>`COALESCE(SUM(CAST(${schema.orders.totalAmount} AS DECIMAL)), 0)` })
        .from(schema.orders)
        .where(eq(schema.orders.status, 'completed'));
      
      const metrics = {
        totalStores,
        activeStores,
        totalUsers,
        totalOrders: totalOrdersResult?.count || 0,
        ordersToday: todayOrdersResult?.count || 0,
        totalRevenue: Number(revenueResult?.total || 0).toFixed(2),
        totalMessages: totalMessagesResult?.count || 0,
        storageUsed: "N/A", // Requiere monitoreo del sistema
        systemStatus: "healthy" as const
      };

      res.json(metrics);
    } catch (error) {
      console.error('Error fetching super admin metrics:', error);
      res.status(500).json({ error: 'Failed to fetch metrics' });
    }
  });

    // WhatsApp logs endpoints
 app.get("/api/whatsapp/logs", authenticateToken, async (_req, res) => {
  try {
    const logs = await storage.getWhatsAppLogs();
    res.json(logs);
  } catch (error) {
    console.error("Error getting WhatsApp logs:", error);
    res.status(500).json({ error: "Error al obtener los logs de WhatsApp" });
  }
});

  app.post("/api/whatsapp/logs", authenticateToken, async (req, res) => {
  try {
    await storage.addWhatsAppLog(req.body);
    res.json({ success: true });
  } catch (error) {
    console.error("Error adding WhatsApp log:", error);
    res.status(500).json({ error: "Error al agregar log de WhatsApp" });
  }
});

    app.get("/api/whatsapp/status", async (req, res) => {
    try {
      const config = await storage.getWhatsAppConfig();
      
      if (!config || !config.accessToken || !config.phoneNumberId) {
        return res.json({
          connected: false,
          configured: false,
          message: "WhatsApp credentials not configured"
        });
      }

      // Test connection by validating token format and configuration
      const domain = process.env.REPLIT_DOMAINS?.split(',')[0];
      const webhookUrl = domain ? `https://${domain}/webhook` : 'https://tu-dominio-replit.com/webhook';
      
      await storage.addWhatsAppLog({
        type: 'info',
        phoneNumber: null,
        messageContent: 'Configuraci√≥n de WhatsApp cargada correctamente',
        status: 'configured',
        rawData: JSON.stringify({ 
          phoneNumberId: config.phoneNumberId,
          webhookUrl,
          timestamp: new Date() 
        })
      });

      res.json({
        connected: true,
        configured: true,
        lastCheck: new Date().toISOString(),
        phoneNumber: config.phoneNumberId,
        businessName: "WhatsApp Business Account",
        webhookUrl: webhookUrl,
        webhookVerifyToken: config.webhookVerifyToken,
        message: "Configuration loaded successfully"
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to check WhatsApp status" });
    }
  });

 app.get("/api/notifications/unread", async (req, res) => {
    try {
      const userId = req.query.userId as string;
      if (!userId) {
        return res.status(400).json({ error: "User ID is required" });
      }
      
      const notifications = await storage.getUnreadNotifications(parseInt(userId));
      res.json(notifications);
    } catch (error) {
      console.error("Error fetching unread notifications:", error);
      res.status(500).json({ error: "Failed to fetch unread notifications" });
    }
  });

  app.get("/api/notifications/count", async (req, res) => {
    try {
      const userId = req.query.userId as string;
      if (!userId) {
        return res.status(400).json({ error: "User ID is required" });
      }
      
      const counts = await storage.getNotificationCount(parseInt(userId));
      res.json(counts);
    } catch (error) {
      console.error("Error fetching notification counts:", error);
      res.status(500).json({ error: "Failed to fetch notification counts" });
    }
  });

  app.post("/api/notifications", async (req, res) => {
    try {
      const notificationData = insertNotificationSchema.parse(req.body);
      const notification = await storage.createNotification(notificationData);
      res.status(201).json(notification);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: "Invalid notification data", details: error.errors });
      }
      console.error("Error creating notification:", error);
      res.status(500).json({ error: "Failed to create notification" });
    }
  });

  app.put("/api/notifications/:id/read", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const notification = await storage.markNotificationAsRead(id);
      if (!notification) {
        return res.status(404).json({ error: "Notification not found" });
      }
      res.json(notification);
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ error: "Failed to mark notification as read" });
    }
  });

  app.put("/api/notifications/read-all", async (req, res) => {
    try {
      const userId = req.body.userId;
      if (!userId) {
        return res.status(400).json({ error: "User ID is required" });
      }
      
      await storage.markAllNotificationsAsRead(parseInt(userId));
      res.json({ success: true });
    } catch (error) {
      console.error("Error marking all notifications as read:", error);
      res.status(500).json({ error: "Failed to mark all notifications as read" });
    }
  });

  app.delete("/api/notifications/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      await storage.deleteNotification(id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting notification:", error);
      res.status(500).json({ error: "Failed to delete notification" });
    }
  });

  // Endpoints que el frontend est√° esperando:
app.get("/api/conversations", authenticateToken, async (req, res) => {
  try {
    const user = (req as any).user;
    const conversations = await storage.getAllConversations(user.storeId); // ‚úÖ Pasar storeId
    res.json(conversations);
  } catch (error) {
    res.status(500).json({ error: "Failed to fetch conversations" });
  }
});


app.get("/api/customers", async (req, res) => {
  try {
    const customers = await storage.getAllCustomers();
    res.json(customers);
  } catch (error) {
    res.status(500).json({ error: "Failed to fetch customers" });
  }
});

app.get("/api/employees", async (req, res) => {
  try {
    const employees = await storage.getAllEmployees();
    res.json(employees);
  } catch (error) {
    res.status(500).json({ error: "Failed to fetch employees" });
  }
});

/**
 * CREAR PRODUCTO con im√°genes (archivos + URLs)
 */

router.post('/products', authenticateToken, (req: any, res: any, next: any) => {
  // Usar multer como middleware inline
  upload.array('images', 5)(req, res, (err: any) => {
    if (err) {
      return res.status(400).json({ error: err.message });
    }
    createProductHandler(req, res);
  });
});



router.delete('/products/:id', authenticateToken, deleteProductHandler);
router.get('/products', authenticateToken, getProductsHandler);
router.get('/products/:id', authenticateToken, getProductByIdHandler);
router.post('/validate-image-url', authenticateToken, validateImageUrlHandler);

// 2. SOLUCI√ìN PARA ERRORES DE L√çNEAS 1241 y 1263 (Storage methods)
// Corrige las llamadas a m√©todos de storage:

// Rutas para categor√≠as (CORREGIDAS)
router.get('/categories', authenticateToken, async (req: any, res: any) => {
  try {
    const user = req.user as AuthUser;
    
   const tenantStorage = await getTenantStorageForUser(user);
    
    // ‚úÖ CORRECCI√ìN: Sin pasar storeId como segundo par√°metro
    const categories = await tenantStorage.getAllCategories();

    res.json(categories);
  } catch (error) {
    console.error('Error fetching categories:', error);
    res.status(500).json({
      error: "Error interno del servidor"
    });
  }
});

router.post('/categories', authenticateToken, async (req: any, res: any) => {
  try {
    const user = req.user as AuthUser;
    const categoryData = { ...req.body };
    
    const tenantStorage = await getTenantStorageForUser(user);
    
    // ‚úÖ CORRECCI√ìN: Solo un par√°metro
    const category = await tenantStorage.createCategory(categoryData);

    res.status(201).json(category);
  } catch (error) {
    console.error('Error creating category:', error);
    res.status(500).json({
      error: "Error interno del servidor"
    });
  }
});

router.put('/categories/:id', authenticateToken, async (req: any, res: any) => {
  try {
    const user = req.user as AuthUser;
    const categoryId = parseInt(req.params.id);
    
    const tenantStorage = await getTenantStorageForUser(user);
    
    // ‚úÖ CORRECCI√ìN: Estructura correcta para updateCategory
    const updateData = { ...req.body };
    const category = await tenantStorage.updateCategory(categoryId, updateData);

    if (!category) {
      return res.status(404).json({ error: "Categor√≠a no encontrada" });
    }

    res.json(category);
  } catch (error) {
    console.error('Error updating category:', error);
    res.status(500).json({
      error: "Error interno del servidor"
    });
  }
});

router.delete('/categories/:id', authenticateToken, async (req: any, res: any) => {
  try {
    const user = req.user as AuthUser;
    const categoryId = parseInt(req.params.id);
    
    const tenantStorage = await getTenantStorageForUser(user);
    
    // Eliminar categor√≠a (m√©todo void)
    await tenantStorage.deleteCategory(categoryId);
    
    // Si no hay excepci√≥n, fue exitoso
    res.json({ success: true });
    
  } catch (error) {
    console.error('Error deleting category:', error);
    res.status(500).json({
      error: "Error interno del servidor"
    });
  }
});

router.post('/upload-image', (req: any, res: any, next: any) => {
  // Aplicar authenticateToken primero
  authenticateToken(req, res, (err: any) => {
    if (err) return next(err);
    
    // Luego aplicar multer
    upload.single('image')(req, res, (err: any) => {
      if (err) return next(err);
      
      // Handler principal
      uploadImageHandler(req, res);
    });
  });
});

const uploadImageHandler = async (req: any, res: any) => {
  try {
    const user = req.user as AuthUser;
    const file = req.file;
    
    if (!file) {
      return res.status(400).json({ error: 'No file provided' });
    }

    const imageUrls = await processProductImages([file], [], user.storeId!);
    
    res.json({
      success: true,
      imageUrl: imageUrls[0]
    });
  } catch (error) {
    console.error('Error uploading single image:', error);
    res.status(500).json({ error: error.message });
  }
};

  router.post('/process-image-url', authenticateToken, async (req: any, res: any) => {
  try {
    const user = req.user as AuthUser;
    const { imageUrl } = req.body;
    
    const processedUrls = await processProductImages([], [imageUrl], user.storeId!);
    
    res.json({
      success: true,
      imageUrl: processedUrls[0]
    });
  } catch (error) {
    console.error('Error processing image URL:', error);
    res.status(500).json({ error: error.message });
  }
});

// Verificar estado completo de la tienda
app.get('/api/test/store-status/:storeId', async (req, res) => {
  try {
    const storeId = parseInt(req.params.storeId);
    
    console.log(`üß™ TESTING AUTO-RESPONSES - Store ID: ${storeId}`);
    
    // ‚úÖ CORRECCI√ìN: Obtener tenantDb primero, luego crear storage
    const { getTenantDb } = await import('./multi-tenant-db.js');
    const { createTenantStorage } = await import('./tenant-storage.js');
    const tenantDb = await getTenantDb(storeId);
    const tenantStorage = createTenantStorage(tenantDb);
    
    // Verificar auto-respuestas en base de datos
    const autoResponses = await tenantStorage.getAllAutoResponses();
    
    console.log(`üìã AUTO-RESPONSES FOUND: ${autoResponses.length}`);
    
    // Verificar configuraci√≥n de WhatsApp
    const whatsappConfig = await storage.getWhatsAppConfig(storeId);
    
    // Verificar respuesta de bienvenida
    const welcomeResponse = autoResponses.find((resp: any) => 
      resp.isActive && resp.trigger === 'welcome'
    );
    
    res.json({
      success: true,
      storeId,
      autoResponsesCount: autoResponses.length,
      autoResponses: autoResponses.map((r: any) => ({
        id: r.id,
        name: r.name,
        trigger: r.trigger,
        isActive: r.isActive,
        messagePreview: r.messageText.substring(0, 50) + "..."
      })),
      whatsappConfigured: !!whatsappConfig,
      phoneNumberId: whatsappConfig?.phoneNumberId || null,
      hasWelcomeResponse: !!welcomeResponse,
      readyForMessages: !!(whatsappConfig && welcomeResponse)
    });
    
  } catch (error) {
    console.error('‚ùå ERROR TESTING AUTO-RESPONSES:', error);
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Simular webhook de mensaje
app.post('/api/test/simulate-webhook/:storeId', async (req, res) => {
  try {
    const storeId = parseInt(req.params.storeId);
    const { phoneNumber = '18494553242', messageText = 'Hola' } = req.body;
    
    console.log(`üé≠ SIMULATING MESSAGE WEBHOOK - Store: ${storeId}, Phone: ${phoneNumber}, Message: "${messageText}"`);
    
    // Obtener configuraci√≥n de WhatsApp
    const whatsappConfig = await storage.getWhatsAppConfig(storeId);
    
    if (!whatsappConfig) {
      return res.json({
        success: false,
        error: "No WhatsApp config found - Cannot simulate webhook"
      });
    }
    
    // Crear webhook simulado
    const simulatedWebhook = {
      object: "whatsapp_business_account",
      entry: [{
        id: "TEST_BUSINESS_ACCOUNT_ID",
        changes: [{
          value: {
            messaging_product: "whatsapp",
            metadata: {
              display_phone_number: whatsappConfig.phoneNumberId,
              phone_number_id: whatsappConfig.phoneNumberId
            },
            messages: [{
              from: phoneNumber,
              id: `test_${Date.now()}`,
              timestamp: Math.floor(Date.now() / 1000).toString(),
              text: {
                body: messageText
              },
              type: "text"
            }]
          },
          field: "messages"
        }]
      }]
    };
    
    console.log(`üì§ PROCESSING SIMULATED WEBHOOK...`);
    
    // Procesar webhook simulado
    const { processWhatsAppMessageSimple } = await import('./whatsapp-simple.js');
    await processWhatsAppMessageSimple(simulatedWebhook);
    
    console.log(`‚úÖ WEBHOOK SIMULATION COMPLETED`);
    
    res.json({
      success: true,
      message: "Webhook simulado exitosamente",
      details: {
        storeId,
        phoneNumber,
        messageText,
        phoneNumberId: whatsappConfig.phoneNumberId
      }
    });
    
  } catch (error) {
    console.error('‚ùå ERROR SIMULATING WEBHOOK:', error);
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Crear respuesta de bienvenida por defecto
app.post('/api/test/create-welcome/:storeId', async (req, res) => {
  try {
    const storeId = parseInt(req.params.storeId);
    
    console.log(`üèóÔ∏è CREATING DEFAULT WELCOME RESPONSE - Store ID: ${storeId}`);
    
    // ‚úÖ CORRECCI√ìN: Obtener tenantDb primero, luego crear storage
    const { getTenantDb } = await import('./multi-tenant-db.js');
    const { createTenantStorage } = await import('./tenant-storage.js');
    const tenantDb = await getTenantDb(storeId);
    const tenantStorage = createTenantStorage(tenantDb);
    
    // Verificar si ya existe
    const autoResponses = await tenantStorage.getAllAutoResponses();
    const welcomeExists = autoResponses.find((resp: any) => resp.trigger === 'welcome');
    
    if (welcomeExists) {
      return res.json({
        success: true,
        message: "Welcome response already exists",
        response: {
          id: welcomeExists.id,
          name: welcomeExists.name,
          trigger: welcomeExists.trigger
        }
      });
    }
    
    // Crear respuesta de bienvenida usando el tenantDb directamente
    const welcomeResponse = {
      name: "Bienvenida",
      trigger: "welcome",
      isActive: true,
      priority: 1,
      messageText: `¬°Hola! üëã Bienvenido a MAS QUE SALUD

¬øEn qu√© puedo ayudarte hoy?

üíä Ver productos
üìû Contactar con soporte
üìç Ubicaci√≥n de tienda
üïí Horarios de atenci√≥n

Simplemente escribe lo que necesitas y te ayudar√©.`,
      requiresRegistration: false,
      menuOptions: "Ver productos,Contactar soporte,Ubicaci√≥n,Horarios",
      nextAction: null,
      menuType: "buttons",
      showBackButton: false,
      allowFreeText: true,
      responseTimeout: 300,
      maxRetries: 3,
      fallbackMessage: "Lo siento, no entend√≠ tu mensaje. ¬øPodr√≠as repetirlo?",
      conditionalDisplay: null
    };
    
    // Insertar usando tenantDb
    const { schema } = await import('../shared/schema.js');
    const [newResponse] = await tenantDb.insert(schema.autoResponses)
      .values(welcomeResponse)
      .returning();
    
    console.log(`‚úÖ DEFAULT WELCOME RESPONSE CREATED: "${newResponse.name}" (ID: ${newResponse.id})`);
    
    res.json({
      success: true,
      message: "Default welcome response created successfully",
      response: {
        id: newResponse.id,
        name: newResponse.name,
        trigger: newResponse.trigger
      }
    });
    
  } catch (error) {
    console.error('‚ùå ERROR CREATING WELCOME RESPONSE:', error);
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});



app.use('/api', router);


  // Health endpoint is defined in index.ts to prevent Vite middleware interference

  // Routes registered successfully - server managed by index.ts
  return app as any;
}

